<!doctype html>
<html lang="hr">
<head>
  <meta charset="utf-8">
  <title>Murder Mystery Evaluator ‚Äî Player1..Player7</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    :root {
      --bg1: #171414;
      --bg2: #2a1c1c;
      --card: #2f2424;
      --accent: #c84b4b;
      --gold: #d4b46e;
      --muted: #b7a9a9;
      --panel: #3b2b2b;
      --glass: rgba(255,255,255,0.03);
    }
    html,body{height:100%;margin:0;padding:0;font-family: "Segoe UI", system-ui, sans-serif;background: radial-gradient(circle at 10% 10%, var(--bg2) 0%, var(--bg1) 60%);}
    .wrap{max-width:1000px;margin:28px auto;padding:20px;border-radius:14px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));box-shadow:0 10px 40px rgba(0,0,0,0.6)}
    .card{background:var(--card);padding:20px;border-radius:12px;color:var(--muted);box-shadow:0 6px 24px rgba(0,0,0,0.5)}
    h1{margin:0 0 8px;color:var(--gold);font-size:1.6rem;letter-spacing:0.6px}
    p.lead{color:#e8ddd0;margin:6px 0 14px}
    .grid{display:grid;grid-template-columns:repeat(4,1fr);gap:10px}
    label{display:block;color:var(--gold);font-weight:600;margin-bottom:6px;font-size:0.95rem}
    input[type="text"], textarea {width:100%;box-sizing:border-box;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:var(--panel);color:#fff}
    textarea{min-height:120px;resize:vertical}
    .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
    button{background:var(--accent);border:none;color:#fff;padding:10px 14px;border-radius:8px;cursor:pointer;font-weight:700}
    button.secondary{background:#4a3a3a}
    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);font-weight:600}
    .players-table{width:100%;margin-top:14px;border-collapse:collapse;background:transparent}
    .players-table th, .players-table td{padding:8px;text-align:left;border-bottom:1px solid rgba(255,255,255,0.03);color:#fff}
    .players-table th{color:var(--gold);background:transparent}
    .out{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.08));padding:12px;border-radius:8px;color:#fff;margin-top:10px;min-height:36px}
    pre#debug{background:#0d0b0b;color:#ddd;padding:12px;border-radius:8px;overflow:auto;margin-top:12px;max-height:320px}
    .top-row{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}
    .small{font-size:0.9rem;color:var(--muted)}
    .file-input{display:none}
    @media(max-width:880px){ .grid{grid-template-columns:repeat(2,1fr)} }
    @media(max-width:520px){ .grid{grid-template-columns:1fr} .top-row{flex-direction:column;align-items:flex-start} }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="top-row">
        <div>
          <h1>üé© Murder Mystery Evaluator</h1>
          <p class="lead">Unesi igraƒçe i pravila pa pritisni <b>Evaluiraj</b>. Rezultati su grupirani po listama igraƒça.</p>
        </div>
        <div class="small">Tip: koristi *min2p*, *p1*, *NOT p2*, numeriƒçke tokene i logiƒçke operator–µ (AND/OR/NOT).</div>
      </div>

      <h3 style="color:var(--gold);margin-top:16px">Unesi vrijednosti igraƒça (po jedan broj u polje)</h3>
      <div class="grid" style="margin-bottom:10px">
        <div><label>Player1</label><input id="p1" type="text" placeholder="npr. 122"></div>
        <div><label>Player2</label><input id="p2" type="text" placeholder="npr. 150"></div>
        <div><label>Player3</label><input id="p3" type="text" placeholder="npr. 122"></div>
        <div><label>Player4</label><input id="p4" type="text" placeholder="npr. 70"></div>
        <div><label>Player5</label><input id="p5" type="text" placeholder="npr. 33"></div>
        <div><label>Player6</label><input id="p6" type="text" placeholder="npr. 33"></div>
        <div><label>Player7</label><input id="p7" type="text" placeholder="npr. 33"></div>
        <div><label>Globalni brojevi</label><input id="globalNumbers" placeholder="npr. 10,200"></div>
      </div>

      <h3 style="color:var(--gold);margin-top:6px">Pravila (JSON array) ‚Äî svako pravilo: {"cond":"...","out":"kod"}</h3>
      <textarea id="rules" rows="8">[
{"cond":"150","out":"300"},
{"cond":"min2p AND p1 AND 150","out":"301"},
{"cond":"min3p AND 150","out":"302"},
{"cond":"33","out":"401"},
{"cond":"33 NOT p2","out":"402"}
]</textarea>

      <div class="controls">
        <button id="evalBtn">‚öñÔ∏è Evaluiraj</button>
        <button onclick="saveToURL()" class="secondary">üíæ Save URL</button>
        <button onclick="exportRules()" class="ghost">üì§ Export Rules</button>
        <button onclick="importRules()" class="ghost">üì• Import Rules</button>
        <input type="file" id="fileInput" class="file-input" accept=".json">
      </div>

      <h3 style="color:var(--gold);margin-top:18px">Rezultati</h3>
      <div id="result" class="out">Nema rezultata jo≈°.</div>

      <h4 style="color:var(--gold);margin-top:12px">Detaljan debug (interni skupovi i evaluacije)</h4>
      <pre id="debug">‚Äî</pre>
    </div>
  </div>

<script>
(function(){
  // helpers
  const getPlayers = () => {
    const players = [];
    for (let i=1;i<=7;i++){
      const el = document.getElementById('p'+i);
      const v = el ? el.value.trim() : '';
      players.push(v === '' ? null : v);
    }
    return players;
  };
  const parseNumberList = s => {
    if(!s) return [];
    return s.split(',').map(x=>x.trim()).filter(x=>x!=='');
  };

  // Build map: number -> array of player indices (0-based)
  function buildNumberMap(players, globalNumbers){
    const map = {};
    players.forEach((val, idx) => {
      if (val === null) return;
      const vals = val.toString().split(',').map(x=>x.trim()).filter(x=>x!=='');
      vals.forEach(v=>{
        if(!map[v]) map[v] = new Set();
        map[v].add(idx);
      });
    });
    // Add global numbers: treat as if every present player also has them
    globalNumbers.forEach(g=>{
      if(!map[g]) map[g] = new Set();
      for(let i=0;i<players.length;i++){
        if(players[i] !== null) map[g].add(i);
      }
    });
    const out = {};
    for(const k in map) out[k] = Array.from(map[k]);
    return out;
  }

  // makeEvaluator (same robust evaluator you provided)
  function makeEvaluator(condString) {
    let s = condString ? condString.replace(/\s+/g,' ').trim() : '';
    const numTokens = Array.from(new Set((s.match(/\b\d+\b/g) || [])));
    const playerTokens = Array.from(new Set((s.match(/\bp\d+\b/ig) || []).map(t=>t.toLowerCase())));
    const minMaxTokens = Array.from(new Set((s.match(/\b(min|max)\d+p\b/ig) || []).map(t=>t.toLowerCase())));

    return function evaluate(context){
      const playersCount = context.players.length;
      const numberMap = context.numberMap;
      const playersForNumber = {};
      numTokens.forEach(n => {
        playersForNumber[n] = (numberMap[n] || []).slice();
      });

      let combinedSet = new Set();
      numTokens.forEach(n => {
        (playersForNumber[n] || []).forEach(i => combinedSet.add(i));
      });
      const countCombined = combinedSet.size;

      const varMap = {};
      numTokens.forEach(n => varMap[n] = (playersForNumber[n] && playersForNumber[n].length>0));

      const players = context.players;
      playerTokens.forEach(pt => {
        const num = parseInt(pt.slice(1),10);
        const idx = num-1;
        if(numTokens.length>0){
          varMap[pt] = combinedSet.has(idx);
        } else {
          varMap[pt] = players[idx] !== null;
        }
      });

      minMaxTokens.forEach(tok => {
        const m = tok.match(/(min|max)(\d+)p/i);
        if(m){
          const typ = m[1].toLowerCase();
          const n = parseInt(m[2],10);
          if(typ === 'min') varMap[tok] = (countCombined >= n);
          else varMap[tok] = (countCombined <= n);
        }
      });

      let expr = s;
      expr = expr.replace(/\bNOT\b/ig, '!');
      expr = expr.replace(/\bAND\b/ig, '&&');
      expr = expr.replace(/\bOR\b/ig, '||');

      const allTokens = minMaxTokens.concat(playerTokens).concat(numTokens);
      allTokens.sort((a,b)=>b.length-a.length);

      allTokens.forEach(tok=>{
        const re = new RegExp('\\b' + tok.replace(/[.*+?^${}()|[\]\\]/g,'\\$&') + '\\b', 'ig');
        const val = (tok in varMap) ? varMap[tok] : false;
        expr = expr.replace(re, val ? 'true' : 'false');
      });

      expr = expr.replace(/\bp\d+\b/ig, 'false');
      expr = expr.replace(/\b\d+\b/g, function(m){
        return (m in varMap && varMap[m]) ? 'true' : 'false';
      });

      expr = expr.replace(/\s+/g,' ');

      let passed = false;
      let evalError = null;
      try {
        passed = Function('"use strict"; return (' + expr + ');')();
      } catch(e){
        evalError = e.toString();
        passed = false;
      }

      let assigned = [];
      if(numTokens.length>0){
        assigned = Array.from(combinedSet).sort((a,b)=>a-b);
      } else if(playerTokens.length>0){
        assigned = playerTokens.map(pt => parseInt(pt.slice(1),10)-1).filter(i=>i>=0 && i<players.length);
      } else {
        assigned = players.map((v,i)=> v!==null ? i : -1).filter(i=>i>=0);
      }

      const notPlayerMatches = s.match(/\bNOT\s+p\d+\b/ig) || s.match(/\bnot\s+p\d+\b/ig) || [];
      notPlayerMatches.forEach(m=>{
        const p = m.match(/\d+/);
        if(p){
          const idx = parseInt(p[0],10)-1;
          assigned = assigned.filter(x=>x !== idx);
        }
      });

      const assignedPlayers = assigned.map(i => 'Player' + (i+1));

      return {
        passed,
        expr,
        evalError,
        numTokens,
        playerTokens,
        minMaxTokens,
        playersForNumber,
        combinedPlayers: Array.from(combinedSet),
        assignedPlayers
      };
    };
  }

  // Main evaluate action
  document.getElementById('evalBtn').addEventListener('click', () => {
    const players = getPlayers();
    const globalNumbers = parseNumberList(document.getElementById('globalNumbers').value);
    const numberMap = buildNumberMap(players, globalNumbers);

    let rules;
    try {
      rules = JSON.parse(document.getElementById('rules').value);
      if(!Array.isArray(rules)) throw 'Rules must be JSON array';
    } catch(e){
      document.getElementById('result').innerText = 'Gre≈°ka pri parsiranju pravila JSON: ' + e;
      return;
    }

    const debugLines = [];
    debugLines.push('Players raw: ' + JSON.stringify(players));
    debugLines.push('Global numbers: ' + JSON.stringify(globalNumbers));
    debugLines.push('Number map (number -> playerIndices): ' + JSON.stringify(numberMap));
    debugLines.push('');

    const outputs = []; // {out:..., players: [...]}
    rules.forEach((r, idx) => {
      const cond = (r.cond || '').toString();
      const out = r.out || ('out_'+idx);
      const evaler = makeEvaluator(cond);
      const res = evaler({players, numberMap});
      debugLines.push(`Rule ${idx+1}: cond="${cond}" out="${out}"`);
      debugLines.push(' -> expr (after replace): ' + res.expr);
      if(res.evalError) debugLines.push(' -> eval error: ' + res.evalError);
      debugLines.push(' -> numTokens: ' + JSON.stringify(res.numTokens));
      debugLines.push(' -> playerTokens: ' + JSON.stringify(res.playerTokens));
      debugLines.push(' -> minMaxTokens: ' + JSON.stringify(res.minMaxTokens));
      debugLines.push(' -> playersForNumber: ' + JSON.stringify(res.playersForNumber));
      debugLines.push(' -> combinedPlayers: ' + JSON.stringify(res.combinedPlayers));
      debugLines.
